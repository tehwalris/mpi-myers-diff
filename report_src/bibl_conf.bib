------------------------------------------------------------------------
 
@ARTICLE{Article,
        AUTHOR =        {},
        TITLE =         {},
        JOURNAL =       {},
        Volume =        {},
        Number =        {},
        Pages =         {},
        Month =         {},
        YEAR =          {},
        Note =          {},
        summary =       {}
        }
@BOOK{Book,
        AUTHOR =        {},
        editor =        {},
        TITLE =         {},
        PUBLISHER =     {},
        YEAR =          {},
        Volume =        {},
        number =        {},
        Series =        {},
        Address =       {},
        Edition =       {},
        Month =         {},
        Note =          {},
        summary =       {}
        }
@BOOKLET{Booklet,
        TITLE =         {},
        Author =        {},
        Howpublished =  {},
        Address =       {},
        Month =         {},
        Year =          {},
        Note =          {},
        summary =       {}
        }
@INBOOK{Inbook,
        AUTHOR =        {},
        editor =        {},
        TITLE =         {},
        CHAPTER =       {},
        pages =         {},
        PUBLISHER =     {},
        YEAR =          {},
        Volume =        {},
        number =        {},
        Series =        {},
        Type =          {},
        Address =       {},
        Edition =       {},
        Month =         {},
        Note =          {},
        summary =       {}
        }
@INCOLLECTION{Incollection,
        AUTHOR =        {},
        TITLE =         {},
        BOOKTITLE =     {},
        PUBLISHER =     {},
        YEAR =          {},
        Editor =        {},
        Volume =        {},
        number =        {},
        Series =        {},
        Type =          {},
        Chapter =       {},
        Pages =         {},
        Address =       {},
        Edition =       {},
        Month =         {},
        Note =          {},
        summary =       {}
        }
@INPROCEEDINGS{Inproceedings,
        AUTHOR =        {},
        TITLE =         {},
        BOOKTITLE =     {},
        YEAR =          {},
        Editor =        {},
        Volume =        {},
        number =        {},
        Series =        {},
        Pages =         {},
        Address =       {},
        Month =         {},
        Organization =  {},
        Publisher =     {},
        Note =          {},
        summary =       {}
        }
@MANUAL{Manual,
        TITLE =         {},
        Author =        {},
        Organization =  {},
        Address =       {},
        Edition =       {},
        Month =         {},
        Year =          {},
        Note =          {},
        summary =       {}
        }
@MASTERSTHESIS{Mastersthesis,
        AUTHOR =        {},
        TITLE =         {},
        SCHOOL =        {},
        YEAR =          {},
        Type =          {},
        Address =       {},
        Month =         {},
        Note =          {},
        summary =       {}
        }
@MISC{Misc,
        Author =        {},
        Title =         {},
        Howpublished =  {},
        Month =         {},
        Year =          {},
        Note =          {},
        summary =       {}
        }
@PHDTHESIS{Phdthesis,
        AUTHOR =        {},
        TITLE =         {},
        SCHOOL =        {},
        YEAR =          {},
        Type =          {},
        Address =       {},
        Month =         {},
        Note =          {},
        summary =       {}
        }
@PROCEEDINGS{Proceedings,
        TITLE =         {},
        YEAR =          {},
        Editor =        {},
        Volume =        {},
        number =        {},
        Series =        {},
        Address =       {},
        Month =         {},
        Organization =  {},
        Publisher =     {},
        Note =          {},
        summary =       {}
        }
@TECHREPORT{Techreport,
        AUTHOR =        {},
        TITLE =         {},
        INSTITUTION =   {},
        YEAR =          {},
        Type =          {},
        Number =        {},
        Address =       {},
        Month =         {},
        Note =          {},
        summary =       {}
        }
@UNPUBLISHED{Unpublished,
        AUTHOR =        {},
        TITLE =         {},
        NOTE =          {},
        Month =         {},
        Year =          {},
        summary =       {}
        }

------------------------------------------------------------------------

@misc{our_source,
  title = {A parallelized version of {M}yers' {O}(nd) diff algorithm},
  howpublished = {\url{https://github.com/tehwalris/mpi-myers-diff}},
  }
  
@inproceedings{moreland2015formal,
  title={Formal metrics for large-scale parallel performance},
  author={Moreland, Kenneth and Oldfield, Ron},
  booktitle={International Conference on High Performance Computing},
  pages={488--496},
  year={2015},
  organization={Springer}
}

@MANUAL{bigDNA1Data,
    TITLE =         {Synechococcus elongatus PCC 7942 = FACHB-805, complete sequence},
    Author =        {},
    Organization =  {Bethesda (MD): National Library of Medicine (US), National Center for Biotechnology Information},
    Address =       {\url{https://www.ncbi.nlm.nih.gov/nuccore/NC_007604.1} [cited 2021-01-14]},
    Edition =       {},
    Month =         {Dec},
    Year =          {2020},
    Note =          {Accession No. NC\_007604.1},
    summary =       {}
}

@MANUAL{bigDNA2Data,
    TITLE =         {Synechococcus elongatus PCC 6301, complete sequence},
    Author =        {},
    Organization =  {Bethesda (MD): National Library of Medicine (US), National Center for Biotechnology Information},
    Address =       {\url{https://www.ncbi.nlm.nih.gov/nuccore/NC_006576.1} [cited 2021-01-14]},
    Edition =       {},
    Month =         {Dec},
    Year =          {2020},
    Note =          {Accession No. NC\_006576.1},
    summary =       {}
}

@MANUAL{smallDNA1Data,
    TITLE =         {Streptomyces aureoverticillatus strain JCM 4347 sequence016, whole genome shotgun sequence},
    Author =        {},
    Organization =  {Bethesda (MD): National Library of Medicine (US), National Center for Biotechnology Information},
    Address =       {\url{https://www.ncbi.nlm.nih.gov/nuccore/NZ_BMSY01000016.1} [cited 2021-01-14]},
    Edition =       {},
    Month =         {Nov},
    Year =          {2020},
    Note =          {Accession No. NZ\_BMSY01000016.1},
    summary =       {}
}

@MANUAL{smallDNA2Data,
    TITLE =         {Streptomyces aureoverticillatus strain JCM 4347 sequence017, whole genome shotgun sequence},
    Author =        {},
    Organization =  {Bethesda (MD): National Library of Medicine (US), National Center for Biotechnology Information},
    Address =       {\url{https://www.ncbi.nlm.nih.gov/nuccore/NZ_BMSY01000017.1} [cited 2021-01-14]},
    Edition =       {},
    Month =         {Dec},
    Year =          {2020},
    Note =          {Accession No. NZ\_BMSY01000017.1},
    summary =       {}
}

% 27899564 
@Article{genbank,
   Author="Benson, D. A.  and Cavanaugh, M.  and Clark, K.  and Karsch-Mizrachi, I.  and Lipman, D. J.  and Ostell, J.  and Sayers, E. W. ",
   Title="{{G}en{B}ank}",
   Journal="Nucleic Acids Res",
   Year="2017",
   Volume="45",
   Number="D1",
   Pages="D37-D42",
   Month="01"
}
        
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Please only add entries above this comment.     %
% All the entries below are exported from Zotero. %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


@inproceedings{bergroth_survey_2000,
	title = {A survey of longest common subsequence algorithms},
	doi = {10.1109/SPIRE.2000.878178},
	abstract = {The aim of this paper is to give a comprehensive comparison of well-known longest common subsequence algorithms (for two input strings) and study their behaviour in various application environments. The performance of the methods depends heavily on the properties of the problem instance as well as the supporting data structures used in the implementation. We want to make also a clear distinction between methods that determine the actual lcs and those calculating only its length, since the execution time and more importantly, the space demand depends crucially on the type of the task. To our knowledge, this is the first time this kind of survey has been done. Due to the page limits, the paper gives only a coarse overview of the performance of the algorithms; more detailed studies are reported elsewhere.},
	booktitle = {Proceedings {Seventh} {International} {Symposium} on {String} {Processing} and {Information} {Retrieval}. {SPIRE} 2000},
	author = {Bergroth, L. and Hakonen, H. and Raita, T.},
	month = sep,
	year = {2000},
	keywords = {algorithm performance, Application software, Books, Computer science, Costs, data structures, Data structures, Dictionaries, DNA, Error correction, execution time, longest common subsequence algorithms, Proteins, Sequences, software performance evaluation, string comparison, string matching, important},
	pages = {39--48},
	file = {IEEE Xplore Full Text PDF:/home/philippe/Zotero/storage/S2FIYTVE/Bergroth et al. - 2000 - A survey of longest common subsequence algorithms.pdf:application/pdf;IEEE Xplore Abstract Record:/home/philippe/Zotero/storage/6GWC4YBL/878178.html:text/html},
}

@inproceedings{arslan_fast_2010,
	address = {Berlin, Heidelberg},
	series = {Lecture {Notes} in {Computer} {Science}},
	title = {A {Fast} {Longest} {Common} {Subsequence} {Algorithm} for {Similar} {Strings}},
	isbn = {978-3-642-13089-2},
	doi = {10.1007/978-3-642-13089-2_7},
	abstract = {The longest common subsequence problem is a very important computational problem for which there are many algorithms. We present a new algorithm for this problem. Let X and Y be any two given strings each of length O(n). We observe that a longest common subsequence can be obtained by using longest common prefixes of suffixes (longest common extensions) of X and Y. The longest common extension problem asks for the longest common prefix of suffixes starting in a given pair of positions in X and Y, respectively. Let e be the number of edit operations, insert, delete, and substitute to change X to Y (i.e. let e be the edit distance between X and Y). Our algorithm visits O(min\{\vphantom{\}}en,(1+2–√)2e+1)O(min\{\vphantom{\}}en,(1+2)2e+1)O({\textbackslash}min{\textbackslash}\{\vphantom{\}}en,(1+{\textbackslash}sqrt\{2\}){\textasciicircum}\{2e+1\}) nodes in the edit graph, and for every visited node, performs one longest common extension query. Each of these queries can be answered in constant time if we represent the strings by a suffix tree or a suffix array. These data structures can be created in linear time. We do not assume that the edit distance e is known beforehand, therefore we try values for e starting with e = 1 (without loss of generality X ≠ Y) and double e until our algorithm finds a longest common subsequence. The total time complexity of our algorithm is O(min\{enlogn,n+e(1+2–√)2e+1\})O(min\{enlog⁡n,n+e(1+2)2e+1\})O({\textbackslash}min{\textbackslash}\{en{\textbackslash}log\{n\},n+e(1+{\textbackslash}sqrt\{2\}){\textasciicircum}\{2e+1\}{\textbackslash}\}). This is a better time complexity result compared to those of existing solutions for the problem when e is small. For example, when e≤13((log(1+2√) n)−1)e≤13((log(1+2)⁡ n)−1)e{\textbackslash}leq {\textbackslash}frac\{1\}\{3\}(({\textbackslash}log\_\{(1+{\textbackslash}sqrt\{2\})\}{\textasciitilde}\{n\})-1) our algorithm finds an optimal solution in time O(n).},
	language = {en},
	booktitle = {Language and {Automata} {Theory} and {Applications}},
	publisher = {Springer},
	author = {Arslan, Abdullah N.},
	editor = {Dediu, Adrian-Horia and Fernau, Henning and Martín-Vide, Carlos},
	year = {2010},
	keywords = {algorithm, dynamic programming, edit distance, longest common extension, longest common subsequence, lowest common ancestor, string, suffix array, suffix tree},
	pages = {82--93},
	file = {Springer Full Text PDF:/home/philippe/Zotero/storage/R8BYV9XN/Arslan - 2010 - A Fast Longest Common Subsequence Algorithm for Si.pdf:application/pdf},
}

@article{altschul_basic_1990,
	title = {Basic local alignment search tool},
	volume = {215},
	issn = {0022-2836},
	doi = {10.1016/S0022-2836(05)80360-2},
	abstract = {A new approach to rapid sequence comparison, basic local alignment search tool (BLAST), directly approximates alignments that optimize a measure of local similarity, the maximal segment pair (MSP) score. Recent mathematical results on the stochastic properties of MSP scores allow an analysis of the performance of this method as well as the statistical significance of alignments it generates. The basic algorithm is simple and robust; it can be implemented in a number of ways and applied in a variety of contexts including straightforward DNA and protein sequence database searches, motif searches, gene identification searches, and in the analysis of multiple regions of similarity in long DNA sequences. In addition to its flexibility and tractability to mathematical analysis, BLAST is an order of magnitude faster than existing sequence comparison tools of comparable sensitivity.},
	language = {eng},
	number = {3},
	journal = {Journal of Molecular Biology},
	author = {Altschul, S. F. and Gish, W. and Miller, W. and Myers, E. W. and Lipman, D. J.},
	month = oct,
	year = {1990},
	pmid = {2231712},
	keywords = {Algorithms, Amino Acid Sequence, Base Sequence, Databases, Factual, Mutation, Sensitivity and Specificity, Sequence Homology, Nucleic Acid, Software},
	pages = {403--410},
}

@article{miller_file_1985,
	title = {A file comparison program},
	abstract = {This paper presents a simple method for computing a shortest sequence of insertion and deletion commands that converts one given file to another. The method is particularly efficient when the difference between the two files is small compared to the files ' lengths. In experiments performed on typical files, the program often ran four times faster than the UNIX diff command. KEY WORDS Edit distance Edit script Filc comparison},
	journal = {Software: Practice and Experience},
	author = {Miller, Webb and {Eugene} and Myers, W.},
	year = {1985},
	keywords = {important},
	pages = {1040},
	file = {Citeseer - Snapshot:/home/philippe/Zotero/storage/D3JSQVIP/download.html:text/html;Citeseer - Full Text PDF:/home/philippe/Zotero/storage/DQ5AYGB3/Miller et al. - 1985 - A file comparison program.pdf:application/pdf;Citeseer - Snapshot:/home/philippe/Zotero/storage/WIQK5G87/download.html:text/html},
}

@article{ukiyama_parallel_nodate,
	title = {Parallel {Multiple} {Alignments} and {Their} {Implementation} on {CM5}},
	author = {Ukiyama, Naoto and Imai, Hiroshi},
	keywords = {important},
	file = {en.pdf:/home/philippe/Zotero/storage/32IC6YHH/en.pdf:application/pdf},
}

@article{jiaoyun_efficient_2010,
	title = {An {Efficient} {Parallel} {Algorithm} for {Longest} {Common} {Subsequence} {Problem} on {GPUs}},
	volume = {1},
	abstract = {Sequence alignment is an important problem in computational biology and finding the longest common subsequence (LCS) of multiple biological sequences is an essential and effective technique in sequence alignment. A major computational approach for solving the LCS problem is dynamic programming. Several dynamic programming methods have been proposed to have reduced time and space complexity. As databases of biological sequences become larger, parallel algorithms become increasingly important to tackle large size problems. In the meantime, general-purpose computing on graphics processing units (GPGPU) has emerged as a promising technology for cost-effective high performance computing. In this paper, we develop an efficient parallel algorithm on GPUs for the LCS problem. We propose a new technique that changes the data dependency in the score table used by dynamic programming algorithms to enable higher degrees of parallelism. The algorithm takes advantage of the large number of processing units and the unique memory-accessing properties of GPUs to achieve high performance. The algorithm was implemented on Nvidia 9800GT GPUs and tested on randomly generated sequences of different lengths. The experiment results show that the new algorithm is about 6 times faster on GPUs than on typical CPUs and is 3 times faster than an existing efficient parallel algorithm, the diagonal parallel algorithm.},
	journal = {Lecture Notes in Engineering and Computer Science},
	author = {Jiaoyun, Yang and Yun, Xu and Yi, Shang},
	month = jun,
	year = {2010},
	keywords = {important},
}

@article{mi_lu_parallel_1994,
	title = {Parallel algorithms for the longest common subsequence problem},
	volume = {5},
	issn = {1558-2183},
	doi = {10.1109/71.298210},
	abstract = {A subsequence of a given string is any string obtained by deleting none or some symbols from the given string. A longest common subsequence (LCS) of two strings is a common subsequence of both that is as long as any other common subsequences. The problem is to find the LCS of two given strings. The bound on the complexity of this problem under the decision tree model is known to be mn if the number of distinct symbols that can appear in strings is infinite, where m and n are the lengths of the two strings, respectively, and m/spl les/n. In this paper, we propose two parallel algorithms far this problem on the CREW-PRAM model. One takes O(log/sup 2/ m + log n) time with mn/log m processors, which is faster than all the existing algorithms on the same model. The other takes O(log/sup 2/ m log log m) time with mn/(log/sup 2/ m log log m) processors when log/sup 2/ m log log m {\textgreater} log n, or otherwise O(log n) time with mn/log n processors, which is optimal in the sense that the time/spl times/processors bound matches the complexity bound of the problem. Both algorithms exploit nice properties of the LCS problem that are discovered in this paper.{\textless}{\textgreater}},
	number = {8},
	journal = {IEEE Transactions on Parallel and Distributed Systems},
	author = {{Mi Lu} and {Hua Lin}},
	month = aug,
	year = {1994},
	note = {Conference Name: IEEE Transactions on Parallel and Distributed Systems},
	keywords = {Error correction, important, Algorithm design and analysis, complexity bound, computational complexity, concurrent-read exclusive-write parallel random-access machine, CREW-PRAM model, Data compression, decision tree model, Decision trees, directed graphs, Genetic engineering, grid directed graph, longest common subsequence problem, maximum-cost path, parallel algorithms, Parallel algorithms, Parallel processing, Pattern recognition, Phase change random access memory, Read-write memory, string subsequences, symbol deletion, totally monotone array},
	pages = {835--848},
	file = {IEEE Xplore Full Text PDF:/home/philippe/Zotero/storage/5TYYRMFS/Mi Lu and Hua Lin - 1994 - Parallel algorithms for the longest common subsequ.pdf:application/pdf;IEEE Xplore Abstract Record:/home/philippe/Zotero/storage/4Q9W5Y9X/298210.html:text/html},
}

@article{allison_bit-string_1986,
	title = {A bit-string longest-common-subsequence algorithm},
	volume = {23},
	issn = {00200190},
	url = {https://linkinghub.elsevier.com/retrieve/pii/0020019086900918},
	doi = {10.1016/0020-0190(86)90091-8},
	language = {en},
	number = {5},
	urldate = {2020-11-29},
	journal = {Information Processing Letters},
	author = {Allison, Lloyd and Dix, Trevor I.},
	month = nov,
	year = {1986},
	pages = {305--310},
}

@article{myers_anond_1986,
	title = {An {O}({ND}) difference algorithm and its variations},
	volume = {1},
	issn = {0178-4617, 1432-0541},
	url = {http://link.springer.com/10.1007/BF01840446},
	doi = {10.1007/BF01840446},
	abstract = {The problems of ﬁnding a longest common subsequence of two sequences A and B and a shortest edit script for transforming A into B have long been known to be dual problems. In this paper, they are shown to be equivalent to ﬁnding a shortest/longest path in an edit graph. Using this perspective, a simple O(ND) time and space algorithm is developed where N is the sum of the lengths of A and B and D is the size of the minimum edit script for A and B. The algorithm performs well when differences are small (sequences are similar) and is consequently fast in typical applications. The algorithm is shown to have O(N + D2 ) expected-time performance under a basic stochastic model. A reﬁnement of the algorithm requires only O(N) space, and the use of sufﬁx trees leads to an O(NlgN + D2 ) time variation.},
	language = {en},
	number = {1-4},
	urldate = {2020-11-29},
	journal = {Algorithmica},
	author = {Myers, Eugene W.},
	month = nov,
	year = {1986},
	pages = {251--266},
	file = {Myers - 1986 - AnO(ND) difference algorithm and its variations.pdf:/home/philippe/Zotero/storage/NCX3967D/Myers - 1986 - AnO(ND) difference algorithm and its variations.pdf:application/pdf},
}

@article{wagner_string--string_1974,
	title = {The {String}-to-{String} {Correction} {Problem}},
	volume = {21},
	issn = {0004-5411, 1557-735X},
	url = {https://dl.acm.org/doi/10.1145/321796.321811},
	doi = {10.1145/321796.321811},
	abstract = {The string-to-string correctionproblem is to determine the distance between two strings as measured by the minimum cost sequence of "edit operations" needed to change the one string into the other. The edit operations investigated allow changing one symbol of a string into another single symbol, deleting one symbol from a string, or inserting a single symbol into a string. An algorithm is presented which solves this problem in time proportional to the product of the lengths of the two strings. Possible applications are to the problems of automatic spelling correction and determining the longest subsequence of characters common to two strings.},
	language = {en},
	number = {1},
	urldate = {2020-11-29},
	journal = {Journal of the ACM},
	author = {Wagner, Robert A. and Fischer, Michael J.},
	month = jan,
	year = {1974},
	pages = {168--173},
	file = {Wagner and Fischer - 1974 - The String-to-String Correction Problem.pdf:/home/philippe/Zotero/storage/YEAFL6XA/Wagner and Fischer - 1974 - The String-to-String Correction Problem.pdf:application/pdf},
}


@ARTICLE{flynns_taxonomy,
  author={M. J. {Flynn}},
  journal={IEEE Transactions on Computers}, 
  title={Some Computer Organizations and Their Effectiveness}, 
  year={1972},
  volume={C-21},
  number={9},
  pages={948-960},
  doi={10.1109/TC.1972.5009071}}
@article{intel_avx,
  title={Intel AVX: New frontiers in performance improvements and energy efficiency},
  author={Firasta, Nadeem and Buxton, Mark and Jinbo, Paula and Nasri, Kaveh and Kuo, Shihjong},
  journal={Intel white paper},
  volume={19},
  number={20},
  year={2008}
}

@misc{edit_graph,
  title = {Image of the algorithm's edit graph},
  howpublished = {\url{http://simplygenius.net/Article/DiffTutorial1l}},
  note = {(\textit{last accessed: 03.01.2021})}
  }
  
@MISC{Zipf,
    Author =        {Encyclopedia of Mathematics},
    Title =         {Zipf law},
    Howpublished =  {URL: \url{http://encyclopediaofmath.org/index.php?title=Zipf_law&oldid=50751}},
    Note =          {(\textit{last accessed: 09.01.2021})},
}


@MISC{diffutils,
    Author =        {GNU},
    Title =         {diff utilities},
    Howpublished =  {\url{http://savannah.gnu.org/git/?group=diffutils}},
    Note = {commit: 7c13bbbeca620e573827636311c5e76e3e3e8da6, 15.03.2020}
}

const MIN_ENTRIES = min. no. of initial entries to compute on one node before the next node is started

// 2b) grow last workload 1-by-1 requiring less initial communication
// rank=1:
// start at d=0, k=0
// grow until d=MIN_ENTRIES: [-d, +d]
// then compute only k=[-d, -d + 2*(MIN_ENTRIES-1)]
// rank=2:
// start at d=MIN_ENTRIES, k = [MIN_ENTRIES, MIN_ENTRIES] = [d, d]
// grow until d=2*MIN_ENTRIES: k=[-d + 2*MIN_ENTRIES, d]
// then compute only k=[-d + 2*MIN_ENTRIES, -d + 2*MIN_ENTRIES + 2*(MIN_ENTRIES-1)]

// rank=worker_rank:
// start at d=(worker_rank-1)*MIN_ENTRIES, k = [(worker_rank-1)*MIN_ENTRIES, (worker_rank-1)*MIN_ENTRIES] = [d,d]
// grow until d=worker_rank*MIN_ENTRIES-1: k=[-d + 2*((worker_rank-1)*MIN_ENTRIES), d]		// only need to receive from worker_rank-1, no need to send

int worker_rank;
int worker_comm_size;

d_start = (worker_rank-1)*MIN_ENTRIES
k_min = d_start
k_max = d_start
if (worker_rank != 1) {
	// Receive (d_start-1, k_min-1) from worker_rank-1
}

int d;
for(d = d_start; d < worker_rank*MIN_ENTRIES; ++d) {
	for (k=k_min; k <= k_max; ++k) {
		// compute entry (d,k) // Test for d=0 or add dummy entry for first worker!
	}
	// Receive entry (d, k_min-2) from worker_rank-1 for next round
	k_min--;
	k_max++;
}

//then compute only k=[-d + 2*((worker_rank-1)*MIN_ENTRIES), -d + 2*((worker_rank-1)*MIN_ENTRIES) + 2*(MIN_ENTRIES-1)]			// #entries = MIN_ENTRIES
//			= [-d + 2*((worker_rank-1)*MIN_ENTRIES), -d + 2*(worker_rank*MIN_ENTRIES -1)]
// == third (else) case below

// UNTIL: d = worker_comm_size*MIN_ENTRIES - 1 -> all nodes have MIN_ENTRIES to compute

for (d = worker_rank*MIN_ENTRIES; d < worker_comm_size * MIN_ENTRIES; ++d) {
	// compute (d, k_max)
	// Send entry (d, k_max) to worker_rank+1
	for k = k_min to k_max-2
		// compute (d,k)
	// Receive entry (d, k_min-2) from worker_rank-1

	// new range for next round d+1
	k_min--;	//extend	// -d has decreased by 1, same number of entries on the left
	k_max--;	//decrease	// -d has decreased by 1, same total number of entries at this node
}


// grow one processes workset by 1 in each round in round-robin:
// workset of process with rank worker_rank grows if: d mod worker_comm_size + 1 = worker_rank
// compute entries row-wise, but compute entry to send first:

for(d=worker_comm_size * MIN_ENTRIES; d < d_max; ++d) {
	if ((d+1) mod worker_comm_size + 1 < worker_rank) {
		// compute (d, k_min)
		// Send entry (d, k_min) to worker_rank-1
		for k = k_min + 2 to k_max
			//compute (d, k)
		// Receive entry (d, k_max+2) from worker_rank+1  //TODO: receive later, only when needed?
	
		// new range for next round d+1
		k_min++;	//decrease	// -d has decreased by 1, but one more entry on the left -> +2
		k_max++;	//extend
	}
	else if ((d+1) mod worker_comm_size + 1 == worker_rank) {
		for k = k_min to k_max
			// compute (d, k)
		// Receive entry (d, k_min-2) from worker_rank-1
		// Receive entry (d, k_max+2) from worker_rank+1
	
		// new range for next round d+1
		k_min--;	//extend	// -d has decreased by 1, same number of entries on the left
		k_max++;	//extend	// 1 additional entry -> += 2
	}
	else {
		// compute (d, k_max)
		// Send entry (d, k_max) to worker_rank+1
		for k = k_min to k_max-2
			// compute (d,k)
		// Receive entry (d, k_min-2) from worker_rank-1
	
		// new range for next round d+1
		k_min--;	//extend	// -d has decreased by 1, same number of entries on the left
		k_max--;	//decrease	// -d has decreased by 1, no additional entry
	}
}


// TODO: termination condition